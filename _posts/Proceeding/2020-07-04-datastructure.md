---
title: dataStructure
layout: single
toc: true
toc_sticky: true
toc_label: 목차
author_profile: true
read_time: true
share: true
related: true
excerpt: 데이터 구조
header:
  overlay_color: "#145252"
categories:
- Proceeding
---

***
# 선형 자료 구조
***

## 동적 배열 ( dynamic array )

동적 배열은 대부분의 언어 표준 라이브러리에서 제공한다. C++의 vector, 자바나 C#의 ArrayList 등이 예이다.
 
- 배열과 달리 자료의 개수 변화에 따라 크기가 변경된다.
- 내부적으로 배열을 이용하기에 배열의 특성을 가진다.
	- 원소들이 메모리의 연속된 위치에 저장된다.
	- 지정된 위치의 원소를 리턴하거나 업데이트하는 동작을 *O*(1)에 할 수 있다.
- 배열과 다른 추가적인 특성을 가진다. 이를 구현하기 위해 새 배열을 동적으로 할당 받아 기존 원소를 복사한다.
	- 배열의 크기를 변경하는 resize 연산이 가능하고, 이 동작에는 배열 크기에 비례하는 시간이 걸린다.
	- 배열의 맨 끝에 1개의 원소를 추가하는 append 연산이 가능하고, 상수 시간이 걸린다.

append() 호출마다 resize()를 실행할 경우, 상수시간에 동작 못하기 때문에 배열의 크기가 커질 때를 대비해 여유분의 메모리를 미리 할당한다.

![동적배열](../../assets/images/posts/dataStructure/dynamicarray.png)

### Append의 재할당
실제로 프로그램 내에서 배열의 크기는 4라고 인식되지만 capacity(용량)까지의 크기는 6이다.
이를 통해 append 연산을 size를 1 늘리는 것으로 끝낼 수 있다. 
하지만 용량까지 모두 찼을 때에는 새 배열을 동적으로 할당받고 기존 원소를 모두 복사한 뒤, 다음 배열에 대한 포인터를 바꿔치기해야한다.
이 때 append 연산을 상수 시간에 수행하기 위해서 특정한 재할당 전략을 취한다.

> 배열의 최종 크기를 알 수 있다면, 용량을 미리 늘려 효율성을 높일 수 있다. 자바에서는 ensureCapacity() 함수를 쓰면 된다.



## 연결 리스트 ( linked list )

배열 원소의 순서를 유지하며 특정 위치에서 원소를 삽입, 삭제할 때의 효율성을 높이기 위해 연결 리스트가 등장하였다.
해당 작업을 상수 시간에 해주는 이 자료 구조는 배열과 많이 다른 형태를 가진다.

- 원소들은 메모리의 사방에 흩어져 있고 각 원소들이 이전과 다음 원소를 가리키는 포인터를 가진다. (양방향)

![동적배열](../../assets/images/posts/dataStructure/linkedlist.png)


```java
class ListNode {
	int el;
	ListNode prev;
	ListNode next;
}
```

- 배열과 달리 특정 위치의 값을 찾는 일에는 선형 시간이 들지만 삽입/삭제 작업에는 상수 시간에 이루어진다.
	- 이전/이후 포인터들의 정보만 바꿔주면 삽입과 삭제가 간단하게 구현된다.

이처럼 배열과 매우 다른 특성을 가지기에 동적 배열과 서로 보완하는 관계로 많이 사용된다.

> 삽입과 삭제를 할 일이 없거나, 맨 끝에서만 하면 된다면 **동적 배열**을 사용한다. 모든 원소를 순회하며 삽입과 삭제한다면 **연결 리스트**가 좋은 선택이다.
> 


| 수행작업 | 동적 배열 | 연결 리스트 |
| -------- | -------- | -------- |
| 이전/다음 원소 찾기  | O(1)     | O(1)    |
| 맨 뒤에 원소 추가/삭제  | O(1)     | O(1)    |
| 맨 뒤가 아닌 원소 추가/삭제  | O(n)     | O(1)    |
| 원소 위치 찾기  | O(1)     | O(n)    |
