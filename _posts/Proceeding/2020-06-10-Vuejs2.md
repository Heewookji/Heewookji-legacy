---
title: Vue.js2 시작하기
layout: single
toc: true
toc_sticky: true
toc_label: 목차
author_profile: true
read_time: true
share: true
related: true
excerpt: 진입장벽이 낮은 프론트 프레임워크 Vue.js2 스터디
header:
  overlay_color: "#145252"
categories:
- Proceeding
---

> Vue.js의 핵심은 간단한 템플릿 구문을 사용해 선언적으로 DOM에 데이터를 렌더링하는 것입니다.

# 시작하기
***

CDN을 이용하거나, 직접 다운받아 로컬로 적용할 수 있다.

```html
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="vue.js"></script>
```

Vue 어플리케이션은 루트 Vue 인스턴스와 컴포넌트 인스턴스라는 두 가지 유형의 Vue 인스턴스로 구성된다.

```javascript
new Vue({/* option */});
```


# 옵션 객체
***

옵션 객체에 애플리케이션을 기술하면 Vue.js가 이 객체를 가지고 Vue 인스턴스를 초기화한다.

```javascript
let vm = new Vue({
            ...
            data: {
                messages: [],
                newMessage: ''
            },
            methods: {
                addMessage(event) {
                    if (!this.newMessage) return;
			...
```
>프로퍼티가 따로 정의되어 있더라도, this로 접근할 수 있다.

## data 객체

```javascript
let vm = new Vue({
            ...
            data: {
                messages: [],
                newMessage: ''
            },
			...
```
객체 literal을 사용한 애플리케이션의 데이터 모델이다. data 객체 프로퍼티에 초깃값을 설정해주는 것이 좋다. 일반 객체를 이용하는 것 외에 일반 객체를 반환하는 함수를 이용할 수도 있다. 컴포넌트의 데이터 구조를 정의할 때는 Vue.js가 항상 이 함수로 새로운 컴포넌트에 대한 새로운 데이터 모델을 생성하기 때문에 객체 반환 함수를 무조건 사용한다.

```javascript
let vm = new Vue({
            ...
            data () {
                return {
                    messages: [],
                    newMessage: ''
                }
            },
			...
```

## methods 객체

```javascript
let vm = new Vue({
            ...
            data () {
                ...
            },
            methods : 
                messageAlert (event) {
                    alert(this.message);
                }
            }
			...
```

옵션 객체의 mothods 프로퍼티는 객체에서 사용하는 모든 메소드를 담는다.
메소드 내에서 데이터 객체 프로퍼티에 this로 접근 가능하지만, 화살표 함수 구문을 사용할 경우
this로 Vue 인스턴스에 접근할 수 없다.

## computed 객체

```html
    <button v-bind:disabled="addDisabled">Add</button>
```

```javascript
let vm = new Vue({
            ...
            computed : {
                addDisabled () {
                    return this.message.length > 10;
                }
            }
			...
```
마찬가지로 메소드 내에서 데이터 객체 프로퍼티에 this로 접근 가능하다.

# template 삽입 방식
***

템플릿을 추가하는 방법은 세 가지가 있다.

```javascript
let vm = new Vue({
        ...
        template: '<li>할일 항목 하나입니다.</li>'
        });
```
- 옵션 객체의 템플릿 프로퍼티를 통해 인라인 템플릿 문자열을 추가하는 방법(마크업이 적을 때 사용)

```html
<div id="app">
   <li>할일 항목 하나입니다.</li>
</div>
```
- 부착 지점인 #app 내에 직접 넣는 방법(최종 결과물에 가까운 템플릿 마크업을 가진다)

```html
<script type="x- template" id="tmplApp">
    <li>할일 항목 하나입니다.</li>
</script>
<script>
    let vm = new Vue({
        ...
        template: '#tmplApp'
        });
</script>
```
- 템플릿 마크업을 script 태그 내에 넣고 옵션 객체의 템플릿 프로퍼티 값으로 해당 id를 주는 방법

# 지시자(directive)
***

지시자는 표현식의 값이 변경될 때 이에 반응해 DOM에 변경 사항을 적용한다. 지시자 정의 객체를 생성하고 전역으로 등록하거나(Vue.directive()) 로컬로 등록하여 사용자 정의 지시자를 만들어 사용할  수 있다.

## 지시자 훅(hook)

```javascript
Vue.directive('focus', {
    inserted: function(el){
        el.focus();
    }
})
```

Vue.js가 지시자 외부의 일을 지시자에 전달하는 함수이다. 사용하기 위해서는 위처럼 지시자 정의 객체 내에 추가해야한다.

### bind
지시자가 처음 바인딩 될 때 한 번만(init) 호출
### inserted
바인딩 된 요소가 부모 노드에 삽입됐을 때 호출
### update
포함하는 컴포넌트의 VNode가 업데이트 됐을 때 호출
### componentUpdated
컴포넌트 VNode와 자식 컴포넌트 VNode가 업데이트된 이후 호출
### unbind
요소에서 지시자 바인딩이 해제될 때 한 번만 호출

## 기본 내장 지시자
### v-model
돔의 태그와 data 객체 사이에 양방향 바인딩을 생성한다.
### v-if
해당 엘리먼트의 존재 여부를 토글하기위해 사용한다.

### v-for 
(별칭) in (원본 데이터) 형식으로 사용되며, 데이터 프로퍼티에 접근하기 위해서 vm.messages 형태를 사용할 필요 없이 messages 로 바로 사용할 수 있다.
> v-bind:key="item.id"

v-for를 사용할 때에는 해당 아이템의 고유한 키 번호를 넘겨주어야한다.
### v-on
> short-hand= `@`

일반적인 리스터를 DOM 요소에 부착하고, 사용자 정의 컴포넌트의 사용자 정의 이벤트를 수신할 수 있다.
### v-bind
> short-hand= `:`

### v-cloak
```html
<head>
	...
    <style>
        [v-cloak] {display: none;}
    </style>
</head>
<body>
    <div id="app" v-cloak>
```
브라우저가 뷰를 로드하고, 뷰가 DOM 제어권을 가져오기전에 HTML을 그대로 표시하므로, 이 현상 해결을 위하여
템플릿 부착지점에 v-cloak 지시자를 추가하여 숨긴다. 뷰는 DOM이 준비되면 v-cloak 지시자를 제거한다.

## 사용자 정의 지시자
```javascript
Vue.directive('focus', {
    inserted: function(el){
        el.focus();
    }
})
```

위와 같은 focus.directive.js 파일을 만든다.

```html
<div id="app">
	...
	<textarea ... v-focus></textarea>
	...
</div>
<script type="module">
	import './directives/focus.directive.js';
	let vm = new Vue({
	...
</script>
```
뷰 인스턴스를 만들기 전 import한 focus 지시자를 해당 DOM에 부착해주면 설정대로 inserted 훅에 호출돼 로직을 수행한다.

# 필터
이중 중괄호 보간법 ({{ }}) 혹은 v-bind 표현법을 이용할 때 텍스트 형식을 지정한다.
필터 객체를 만들어 전역으로 등록하거나(Vue.filter()) 컴포넌트 옵션 객체의 filters 프로퍼티를 이용해 로컬로 등록할 수 있다.

```javascript
const formatter = new Intl.DateTimeFormat('en-US', {
    year: 'numeric', month: 'long', week: 'long', day: 'numeric',
    hour: 'numeric', minute: 'numeric', second: 'numeric'
});

Vue.filter('datetime', function (value) {
    if (!value) return '';
    return formatter.format(value);
})
```

위와 같은 datetime.filter.js 파일을 만든다.

```html
<script type="module">
	...
	import './directives/datetime.filter.js';
	...
</script>
```

```javascript
export default {
   ...
    template: `<li>{%raw%}{{item.createdAt | datetime}}{%endraw%}</li>`
		...
```

import 해준 뒤, 사용하고자 하는 곳에서 파이프( &#124; )로 필터를 추가한다.


>  message &#124; filterA &#124; filterB 

>  message &#124; filterA('arg1', arg2) 


필터는 체이닝하거나, 여러 인수를 받을 수 있다. 필터의 함수는 항상 첫 번째 인수로 표현식의 값(이전 체이닝의 결과)를 받기 때문에, 체이닝의 경우 filterA의 결과는 filterB의 인수가 된다.
두 개의 인수를 받는 filterA는 사실 세 개의 인수를 받고 (첫 번째가 표현식의 값이므로 message), 두 번째 인수(arg1)는 문자열, 세 번째 인수(arg2)는 자바스크립트 표현식이기에 표현식 실행 이후 결과값이 전달된다.

# Vue 인스턴스 LifeCycle
***

인스턴스의 라이프 사이클 동안 각 단계별 로직을 정의할 수 있다.
![라이프 사이클](../../assets/images/posts/vue/lifecycle.png)
## beforeCreate
인스턴스 내부 이벤트, 라이프 사이클 상태 초기화 이후 호출
## created
인스턴스 주입, 반응형 시스템 초기화 이후 호출
## beforeMount
Vue.js가 템플릿 컴파일 완료 후, 생성된 DOM을 렌더링 할 준비 이후 호출
## mounted
DOM 업데이트 이후 호출, UI 상호작용 가능하며 인스턴스가 완전한 기능 수행
## beforeUpdate
데이터 변경 이후 DOM 업데이트 전 호출, 추가적 데이터 변경이 DOM 업데이트를 다시 트리거하지 않음
## updated
DOM이 데이터 변경 사항 기반으로 업데이트된 이후 호출
## activated
keep-alive 컴포넌트 활성화 시 호출
## deactivated
keep-alive 컴포넌트 비활성화 시 호출
## beforeDestroy
인스턴스 파괴 전 호출
## destroyed
인스턴스 파괴 후 호출
## errorCaptured
자식 컴포넌트에서 에러 검출 시 호출
# 컴포넌트(component)
***

Vue 인스턴스로써 생성 중에 Vue 인스턴스와 같은 option 객체를 받는다.   
전역 컴포넌트를 등록할 땐 `Vue.component(id, [definition])`을 사용한다.
- 첫 번째 인자는 컴포넌트의 id로, 템플릿에서 사용할 태그 이름이다. 
- 두 번째 인자는 컴포넌트 정의로 옵션 객체나 옵션객체를 반환하는 함수가 된다. 

컴포넌트는 옵션 객체를 부모 컴포넌트의 프로퍼티에 추가함으로써
다른 Vue 인스턴스의 범위 안에서만 쓸 수 있게 로컬로 등록할 수도 있다.

## 컴포넌트의 참조와 스코프, 책임
컴포넌트는 자체의 고립된 스코프를 가지기 때문에 자식 컴포넌트에서 부모 데이터를 직접 참조할 수 없다.
따라서 자식 컴포넌트의 옵션 객체에서 props 프로퍼티를 부모 데이터와 연결해주어야한다.


> 컴포넌트는 하나의 책임에 집중해야한다.
> studyList는 스터디 목록을 렌더링하는 것에 집중하고, 스터디 삭제나 추가에 대해서는 관여하지 않는다.

```html
<div id="app">
 <todo-item :items="items" @delete="deleteItem">
 </study-list>
</div>
```
studyList 컴포넌트에서 부모데이터 studies를 items로 받고 있고, delete 사용자 정의 이벤트에 대해 deleteStudy
리스너를 부착하였다. (해당 컴포넌트에서 this.$emit() 메소드로 트리거한다)

## 컴포넌트 생성

컴포넌트를 먼저 등록해야 부모 컴포넌트에서 사용할 수 있다.


- 첫 번째 방법

```javascript
Vue.component('todo-item', {
  template: '<li>할일 항목 하나입니다.</li>',
  props: ['todo']
});

var app = new Vue(...)
```
```html
<div id="app">
  <!-- todo-item 컴포넌트의 인스턴스 만들기 -->
  <todo-item></todo-item>
</div>
```



- 두 번째 방법

컴포넌트를 위한 TodoItem.js 파일을 만든 뒤 해당 파일에 작성한다.

```javascript
import TodoItemDetail from "./TodoItemDetail.js";
export default {
  name: "TodoItem",
  template: `<li>할일 항목 하나입니다.
		<todo-item-detail></todo-item-detail>
		</li>`,
  props: {
    items: {
      type: Array,
      required: true,
    },
  },
  methods: {
    deleteItem(item) {
      this.$emit("delete", item);
    },
  },
};
```

ES6 모듈 파일을 만들어 컴포넌트 정의 옵션 객체를 내보낸다. 하위 컴포넌트에서 emit으로 발생한 이벤트를
부모 컴포넌트에서 수신할 수 있다. 마찬가지로 또 다른 하위 컴포넌트를 import하여 컴포넌트안에 집어넣을 수 있다.
전체 어플리케이션은 다음 예시와 같이 컴포넌트로 나뉘어 구성되는 것이 좋다.

```html
<div id="app">
  <app-nav></app-nav>
  <app-view>
    <app-sidebar></app-sidebar>
    <app-content></app-content>
  </app-view>
</div>
```

# 믹스인(Mixins)
코드 재사용을 위해 믹스인을 활용할 수 있다. Vue.js는 컴포넌트의 옵션 객체에 믹스인을 혼합한다. 따라서 여러 컴포넌트에서 해당 기능을 사용할 수 있다.
믹스인과 컴포넌트 모두 같은 옵션을 포함하는 경우 옵션의 값에 따라 다른 방식으로 병합한다

> 믹스인은 로컬 또는 전역으로 적용할 수 있고, 전역으로 등록되더라도 선언 후 사용하는 컴포넌트, 필터, 지시자와는 다르게 <u> 전역 설정 이후 생성되는 모든 Vue 인스턴스에 자동으로 적용된다.</u>

## 로컬 믹스인

```javascript
export default {
  created() {
    console.log(`${this.$options.name} created`);
  },
...
};

```

위와 같이 mixins/(이름).mixin.js 파일을 만든다.
믹스인 내부에서 this.$options를 통해 인스턴스에 접근이 가능하다.

```html
<script type="module">
    let vm = new Vue({
    name: "mainApp",
    mixins: [lifecycleLogger],
...
</script>
```

위처럼 root에서는 해당 믹스인 파일을 임포트하고, mixins 프로퍼티에 지정한다.

```javascript
import lifecycleLogger from '../mixins/lifecycle-logger.mixin.js';
export default {
    name: 'MessageListItem',
    mixins: [lifecycleLogger],
...
};
```

컴포넌트에서도 마찬가지로 지정을 해주면, 해당 믹스인에서 각 인스턴스 라이프 사이클의 여러 단계를 확인할 수 있다.

# 플러그인(Plugins)

플러그인은 뷰 프레임워크에 확장성을 제공한다. Vue에서 플러그인을 만드려면 install() 메서드를 가진 일반 객체를 생성하면 된다. install() 메서드의 인자로는 확장된 기능을 적용할 ```Vue 생성자```와 ```플러그인 옵션 객체``` 총 두 개가 있다.

```javascript
const switchers = {
  created: true,
  destroyed: true,
};

export default {
  install(Vue, options) {
    
    //Vue.globalMethod = function () {};

    //Vue.directive("directive", {});

    //Vue.prototype.$method = function (methodOptions) {};

    Object.assign(switchers, options);

    Vue.mixin({
      created() {
        if (switchers.created) {
          console.log(`${this.$options.name} created`);
        }
      },
      destroyed() {
        if (switchers.destroyed) {
          console.log(`${this.$options.name} destroyed`);
        }
      }
    });
  }
};

```

위와 같이 plugins/(이름).plugin.js 파일을 만든다.
해당 플러그인 안에서는 정적 메소드 또는 프로퍼티를 Vue 생성자 안에 추가할 수 있고, 사용자 정의 지시자, 필터, 컴포넌트, 믹스인을 만들 수 있다. 그리고 Vue.prototype에 인스턴스 메소드를 추가할 수도 있다.

Object.assign() 메서드로 인자로 넘겨받은 옵션객체 내의 switchers를 미리 정의된 switchedrs와 병합한다. 


```html
<script type="module">
 import lifecycleLoggerPlugin from './plugins/lifecycle-logger.plugin.js';
...
// 플러그인의 install 메서드를 호출
Vue.use(lifecycleLoggerPlugin, { destroy: false});
...
</script>
```

이후 앱에서 플러그인을 사용하려면 import한 뒤, Vue.use()를 호출하면 된다.
