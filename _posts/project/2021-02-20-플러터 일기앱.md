---
layout: post
title: 사이드 - 일기 어플리케이션 mongle
subtitle: Flutter로 일기앱을 만들어보다
tags:
- Project
header-style: text
---

### 계기

`flutter`로 채팅 앱을 하나 만들어보고, 더 재밌는 것을 만들어 출시까지 해보고 싶어서 UX/UI 디자이너 2명과 함께 어플리케이션을 만들기로 했다. 개발자가 한명이기 때문에 크기가 작은 앱을 만들어야 한다고 생각했고 여러 분야 중 일기앱으로 결정을 하였다. '어떤' 일기앱을 만들 것인지는 유저 리서치와 페르소나, 브레인스토밍 등을 통해 공동 기획하였다. 처음에는 3개 정도의 화면을 가진 아주 작고 단순한 앱을 생각했지만, 우리의 욕심으로 늘어난 기능과 화면, 디테일 덕분에 개발 기간에 1달 반 정도 걸린 것 같다. 최종 구현은 아래와 같다.

<video width="320" controls>
  <source src="/img/in-post/project/mongle/1.mov" type="video/mp4">
</video>
<video width="320" controls>
  <source src="/img/in-post/project/mongle/2.mov" type="video/mp4">
</video>
<video width="320" controls>
  <source src="/img/in-post/project/mongle/3.mov" type="video/mp4">
</video>
<video width="320" controls>
  <source src="/img/in-post/project/mongle/4.mov" type="video/mp4">
</video>

#### 스토어 링크 
- [ios](https://apps.apple.com/us/app/mongle/id1553717248)
- [android]()

### 화면 및 기능 정의

최종적으로 정한 컨셉은 '캐릭터들이 하루마다 질문을 하고 답변을 받음으로써 진화하거나 다른 캐릭터가 오는
귀여운 일기앱'이 되었다. 각 캐릭터들은 개성을 가지고 있기 때문에 디자이너는 여러 캐릭터 디자인을 ~~재미있게~~ 해볼 수 있고, 개발하는 내 입장에서도 상태값을 이용한 게임같은 로직이 재밌을 것 같았다.

그 다음, 서로 생각한 아웃풋이 다를 수 있기 때문에 각자 아이디어 스케치를 하였다. 아래는 내가 생각했던 어플리케이션 흐름과 화면들이다.

![스케치](/img/in-post/project/mongle/아이디어스케치.png)

그 다음에는 서로의 아이디어 스케치를 보고 필요한 기능과 화면들에 대해서 조율했고, 그 이후 기능 명세서를 같이 작성하였다. 기능 명세서를 같이 썻음에도 서로 다르게 이해하는 일이 있어 다음부터는 기능명세서를 조금 더 꼼꼼히 작성해야할 필요성을 느꼈다.

![기능명세서](/img/in-post/project/mongle/기능명세서.png)

그 후 디자이너에게 레이아웃을 어느 정도 맞춰볼 수 있는 러프한 와이어프레임을 받았다. 디자인 팀과 분리되어 개발에 들어가고, 최종 디자인 가이드와 asset들을 제플린으로 받을 때까지 필요한 기능과 로직들을 개발하였다.

![와이어프레임](/img/in-post/project/mongle/와이어프레임.png)

### 라이브러리 및 구조

이번 앱은 서버 없이 로컬 DB(sqlite)에 데이터를 저장한다. 또한 지난번에 쓴 `stacked`과 같은 라이브러리를 이용하지 않고, `Provider`만을 이용해서 작업을 했다.

#### DB 구조

DB는 `Sqlite`를 사용하였고, 웹 Erd툴인 `Erdcloud`를 사용해 아래와 같이 구성하였다. 

- home : 홈 캐릭터 자리 배치 로직에 사용
- home_location : 자리와 캐릭터 연결
- character : 캐릭터 정보
- status : 캐릭터 진화 상태 정보
- question : 질문 정보
- diary : 사용자가 쓰는 일기 정보

![erd](/img/in-post/project/mongle/erd.png)

#### 소프트웨어 구조

- services : DB, Notification 등 서비스의 설정과 메서드를 제공
- sql : DB service 사용하여 테이블마다 sql 메서드 제공
- models : 데이터 모델
- providers : sql과 model 사용하는 프로바이더
- screens : provider 사용하여 화면 UI 제공
- widgets : screen에 포함된 UI 조각
- util : 작은 크기의 유틸 메서드 제공

![구조](/img/in-post/project/mongle/폴더구조.png)

### 사용 라이브러리
```dart
dependencies:
  flutter:
    sdk: flutter
  provider: ^4.3.2+2
  path_provider: ^1.6.24
  path: ^1.7.0
  sqflite: ^1.3.2+1
  built_value: ^7.1.0
  intl: ^0.16.1
  flutter_svg: ^0.19.1
  flutter_local_notifications: ^3.0.2
  flutter_native_timezone: ^1.0.4
  url_launcher: ^5.7.10
  auto_size_text: ^2.1.0
  audioplayers: ^0.17.3
```

### 배운 것들

#### 로직

일기 쓰기에 따른 홈 자리 배치와 캐릭터 성장 로직을 작성하며 여러 예외 상황을 고려하는 일이 많았다.
캐릭터들은 하루마다 자리가 바뀌어야하고, 일정 상태에 도달하면 진화를 하면서 홈 자리에서 떠나고, 다시
빈 자리로 돌아오는 등의 로직을 수행했다. 작업을 하며 생각하지 못했던 예외 상황들은 테스트 코드의
필요성을 느끼게 했다.

#### 불변 객체

`built_value`를 이용해 불변 객체에 대한 개념을 배웠다. 본래는 json_serializer만 수행하는
패키지를 사용하려 했으나, 여기저기 이동하는 model들이 불변하는 성질을 가지면 후에 디버깅할 때도
편하겠다는 생각을 하였다. `built_value`에서 사용하는 빌더 패턴 또한 가독성에 좋았다.

#### 커스텀 디자인 구현

디자이너들과 협업하다보니 커스텀 디자인에 대한 요청으로 `canvas`를 직접 다뤄야할 일이 많았다.
말풍선같은 이미지가 반응형 화면에 따라 일정한 그림자를 갖게 하거나, 화면을 채우는 커스텀 애니메이션을
만들 때 관련해서 많은 기능을 사용해볼 수 있었다. 또한 여러 크기의 화면에서도 이미지들이 항상
일정한 위치에 있도록 배치하는 방법에 대해서도 배웠다.

#### timezone과 local assets
마지막으로 일기 데이터를 저장하고 불러오거나 알람을 설정할 때, timezone에 대한 처리방법을 배웠다.
또, 디자이너에게 받은 폰트나 이미지, 사운드 파일을 `flutter`에서 다루는 것도 더 익숙해졌다.

### 아쉬웠던 것들

재밌게 진행하며 배운 것도 많았던 프로젝트였지만, 아쉬운 점도 많았다.

#### 프로바이더의 역할

먼저 프로바이더를 잘못 적용한 것 같다. 처음 프로바이더를 만들 때, 데이터 모델에 대응하는 공통적이고 일반적인 메서드를 제공하는 것으로 생각해버렸다. 이로 인해 UI단에는 프로바이더에서 제공하지 못하는 구체적인 비즈니스 로직이 들어가게 되었고, 다른 상태값을 가진 동일한 프로바이더들을 식별하기 위한 로직들이 추가됐으며, 프로바이더 내부는 너무 거대해졌다. 이 앱이 작은 크기였기 때문에 마무리할 수는 있었지만, 유지보수하기에는 마음 아픈 코드들을 만들었다고 생각한다.

#### dao의 역할

`Data Access Object`는 DB를 사용하여 데이터의 조회 및 조작하는 기능만 전담하는 오브젝트이다.
앱에서 dao에 해당하는 것이 sql 클래스들이었는데, 트랜잭션 문제로 비즈니스 로직들이 들어가버렸다.
이 앱은 사용자가 일기를 쓰고, 정해진 조건에 도달하면, 캐릭터의 상태값이 변한다. 중간에 예기치 못한
사고로 종료가 되면 `데이터 무결성`을 보장하기 위해 해당 로직으로 인한 변동사항이 롤백되어야한다.

`Spring`을 사용할 때는 별 생각없이 서비스 단에서 트랜잭션을 사용하였으나, `Dart`에서는 내가 찾지 못한 것인지 해당 기능을 도와주는 패키지가 없었다. 따라서 비즈니스 로직 단에서 트랜잭션 객체를 sql 클래스에 넣어주거나, sql 클래스에서 비즈니스 로직 코드를 넣거나 결정해야했다. 
결과적으로 sql 클래스 메서드 중 트랜잭션이 필요한 곳은 비즈니스 로직을 가지게 되었고, 정말 보기에 안좋았다. 트랜잭션 처리에 대한 정보를 더 찾아보고 적용해야할 것 같다.

#### 테스트 코드

처음 구상했던 앱은 굉장히 작은 크기였기 때문에, 테스트 코드를 배워서 꼭 적용해보고 싶었다.
하지만 점점 커져가는 앱을 구현하는 것에 점점 신경을 쏟게 되고, 결과적으로 이번 프로젝트에는 적용을 
하지 못했다. `flutter` 개발에 조금 더 익숙해진 다음 프로젝트부터는 테스트 코드와 `TDD`를
발이라도 담가보려고 한다.