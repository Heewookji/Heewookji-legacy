---
layout: post
title: 인하대 블랙보드 2차 인증 프로젝트
subtitle: LMS 서드파티 어플리케이션을 만들어보다
tags:
- Project
header-style: text
---

### 계기

재직중이던 회사가 [블랙보드](https://ko.wikipedia.org/wiki/%EB%B8%94%EB%9E%99%EB%B3%B4%EB%93%9C_%EC%A3%BC%EC%8B%9D%ED%9A%8C%EC%82%AC)라는 글로벌 LMS 회사와 파트너쉽을 맺고, 블랙보드를 이용하고 있는 한국 교육기관들의 커스터마이징에 대해 담당하기로 하였다.
기본적인 LMS의 코어 기능에 대해서는 제공이 되지만, 한국 대학교들의 특성상 커스터마이징 할 기능들이 많기 때문에 고객사(교육기관들)의 요청이 많던 시기였다.

인턴 2개월 차로 일하고 있던 나는 큰 프로젝트는 아니지만 작은 기능을 구현할 주니어 개발자로써 블랙보드 개발을 맡게 되었다. 이 때, 처음으로 맡게 된 프로젝트가 바로 인하대학교 블랙보드 LMS 시스템의 2차 인증이었다. 당시 교육부에서는 온라인 수업을 진행하는 교육기관들에게 1차 인증(아이디/패스워드) 외에 추가적으로 2차 인증을 구현하라는 정책을 내려보냈고, 그에 따라 1차 로그인 후 이메일/모바일 어플리케이션으로 2차 인증을 진행하는 프로젝트를 맡았다. 내가 구현해야할 부분은 사용자의 1차 인증 결과에 따라 사용자를 어느 로직으로 보내주어야할지 결정하는 것이었고, 결정된 사항을 바탕으로 1차 로그인 실패, 모바일 앱 인증 혹은 이메일 인증으로 넘긴 뒤 결과값에 따라 최종 로그인 성공/실패를 하는 것이다. 주니어 개발자 혼자 2주 안에 개발 완료가 가능하다고 결정된 뒤 전달 받았고, 그렇게 혼자 개발을 시작했다.

### 고생담

이제 막 블랙보드와 파트너쉽을 맺었기 때문에 회사 내에서 블랙보드에 대해 질문할 수 있는 시니어 개발자는 없었고, 회사에서 블랙보드 업무를 담당하는 대리님과 블랙보드 측 직원에게 블랙보드 커뮤니티의 영어 원문 글들을 소개받아 정보를 수집했다. 여지껏 폭포수와 같이 진행되는 프로젝트만 알고 있었기 때문에 새로운 기능을 서비스 운용과 상관없이 바로 추가하고 사용할 수 있다고 하는 것이 신기했다. 이게 바로 지속적으로 선적하고 반영한다는 것인가? 했었지만 그런게 아니라 애초에 모듈화를 고려한 시스템이었다. 블랙보드는 서드파티 개발자들이 만든 부가적 기능들이 기존 기능에 추가될 수 있도록 시스템을 설계해 놓았고, 해당 확장프로그램들은 빌딩블럭이라는 단위로 시스템에 올라가게 된다. 개발자의 입장에서 보면 개발한 웹 프로젝트를 war 파일로 만든 뒤, 시스템 관리자 권한으로 서비스되고 있는 시스템에 업로드하기만 하면 되는 것이었다. 여기까지는 굉장히 간단하지만, 문제는 설정에 대한 정보들이었다.

#### 개발을 하려면 VM부터 올려야한다구요?

VM(Virtual Machine), 글로벌 기업이며 다양한 서드 파티 개발자들을 고려해야하는 블랙보드는 환경에 대한 진입 장벽을 낮추기 위하여 BlackBoard LMS 버전에 따라 여러 VM 이미지들을 제공한다. 이를 이용해 개발자는 Vagrant와 VirtualBox를 이용하여 개발용 우분투 OS를 올리고, 그 OS안에 있는 블랙보드 LMS 서비스를 구동해야 개발의 첫 발을 뗄 수 있다. 당연히 해당 부분들에 대해 몰랐으므로, 커뮤니티 원문들을 읽으며 VM 개발환경을 설정하고 LMS 서비스를 올리는 일에 시간을 소요했다.

#### 올렸는데, 어떻게 확인하나요?

웹 프로젝트를 톰캣에 배포하여 구동하면, 내가 설정한 컨텍스트를 확인하면 된다. 구동이 되지 않았다면, 로그를 확인해 문제점을 찾으면 된다. 블랙보드의 경우에는 서드파티 개발자들이 올린 컨텍스트들을 정해진 규칙에 따라 관리할 것이므로, 해당 설정 정보들을 알아야했다. 커뮤니티 글을 찾아, war 파일을 업로드할 때 블랙보드 설정 파일에 있는 메타 정보들을 이용해 Primary한 컨텍스트 루트를 만들어준다는 것을 확인하였다. 해당 컨텍스트로 접속해보니 제대로 올라오지 않았다. 이를 확인하려면 에러를 찍어주는 로그를 VM 속 어느 경로에서 찾을 수 있는지 알아야했다. 다시 커뮤니티를 뒤져가며 내가 올린 빌딩블럭의 로그를 어디서 확인할 수 있는지 찾았다. 이와 같이 내가 만든 껍데기 웹 프로젝트가 올라갔는지를 확인하는 일에도 시간을 소요했다.

#### 올라간 것 확인했는데, 그러고보니 코어 기능에 제 프로그램이 끼어들 수 있나요?

이제 본격적으로 기능을 구현할 시간이 됐다. 내가 구현해야할 기능은 <u>1차 로그인 결과값에 따라 2차 인증을 할 것인지 결정하고 사용자가 선택한 2차 인증으로 보내준 뒤, 최종 로그인 하는 기능</u>이다. 그런데, 백단에서 1차 로그인 작업 이후 내가 끼어들 수 있는지에 대한 의구심이 들었다. 블랙보드의 코어는 공개되어 있지 않고, 로그인 관련하여 내가 바꿀 수 있는 부분은 오로지 login.jsp - 다시 말해 로그인 페이지 뿐이었다.
  
![인하대학교의 블랙보드 로그인 페이지](/img/in-post/project/inha/login.png)

기존에 구현된 'auto-sign-on' 빌딩블럭을 참고하면 해당 기능을 구현할 수 있다고 전달받아 해당 빌딩블럭의 소스를 살펴보았지만, 이것은 블랙보드의 로그인이 아닌, 다른 곳에서 로그인한 뒤 블랙보드에 sso 로그인을 하도록 해주는 빌딩블럭이었다. 다른 곳에서 로그인 작업을 하고 sso로 블랙보드 LMS에 로그인을 해준다면, 중간 로직을 직접 넣어주면 되지만 인하대학교는 블랙보드의 로그인을 그대로 이용하고 있고 블랙보드의 코어는 공개되어 있지 않다. 따라서 다시 커뮤니티의 글들을 읽고 다른 서드파티 개발자가 똑같은 이슈를 가졌는지를 찾았다. 로그인 시도가 3회 이상 실패한 이후 1차 로그인 결과에 상관없이 로그인을 막는 'LoginFilter'라는 빌딩블럭이 있다는 것을 전달받은 뒤, 이 빌딩블럭이 1차 로그인과 최종 로그인 작업 사이에 인터셉트하는 기능이라 유추하고 확인해보았다. 해당 빌딩블럭은 블랙보드 플랫폼 라이브러리에서 제공하는 AbstractUsernamePasswordPostValidationCheck 클래스를 extend한 뒤, 1차 로그인 결과값을 받는 메서드를 오버라이딩하여 1차 로그인 결과값을 바탕으로 이후 로그인을 완료할 것인지로 구현되어있었고 이것을 이용하여 원하는 기능을 구현할 수 있을 것이라 생각했다. 하지만 저 메소드 안에서 사용자와 상호작용하여 2차 인증 페이지로 보내줄 수는 없기 때문에, 일단 내가 사용할 수 있는 프론트 페이지인 login.jsp로 다시 보내주어야했다. 다시 말해, login.jsp에서 유저가 1차 로그인 시도를 하면, 내가 구현한 빌딩블럭에서 끼어들어 제공받은 1차 로그인 결과값으로 2차 인증 대상자인지를 판단하고, 2차 인증 대상자라면 해당 결과 코드값과 함께 로그인을 반려한다. 반려된 코드값을 login.jsp에서 실제 실패인지, 2차 인증 추가 로직이 필요하여 반려된 것인지 확인한 뒤, 2차 인증 모달을 띄운다.

#### 끼어들어서 반려하긴 했는데, 이후 최종 로그인은 그럼 어떻게 하죠?

로그인을 반려시키고 login.jsp에서 2차 인증 모달을 띄워 유저가 2차 인증을 완료한다. 문제는 그 이후, 최종 로그인이 완료된 유저를 다시 어떻게 로그인 성공시킬 것인지였다. 유저는 1차 로그인 정보를 입력한 뒤,(로그인 시도가 실제로는 실패했음을 모르고) 2차 인증을 성실히 진행하였고, 최종 로그인을 기대하고 있을 것이다. 여기서 쓸 수 있는 것을 고민하다가, 이미 도구가 주어져있음을 깨달았다. auto-sign-on 빌딩블럭에서는 블랙보드 로그인이 아닌 sso 링크를 통한 로그인 기능을 제공한다. 따라서 2차 인증까지 완료된 코드값과 함께 sso 링크를 보내 login.jsp에서 리다이렉트할 수 있도록 만들었고, 해당 기능은 생각한대로 잘 동작하였다.

#### sso링크를 이용했을 때, 보안 이슈

구현을 한 뒤, 곰곰히 생각에 빠졌다. 