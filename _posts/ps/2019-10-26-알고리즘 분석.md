---
layout: single
title: 알고리즘 분석
feature-img: "assets/img/portfolio/cake.png"
img: "assets/img/portfolio/cake.png"
date: 26 October 2019
tags: [알고리즘]
---

# 알고리즘이란

주어진 문제를 해결하는 한 가지 방법을 명료하게 써 놓은 것을 알고리즘이라고 한다.

명료하고 모호하지 않은 표현을 위해 대개 의사 코드나 그것을 구현한 소스 코드의

형태로 설명한다. 

알고리즘을 평가하는 기준은 사용 시간과 공간이 있다.

- 시간
    알고리즘의 수행 속도를 말한다.

- 공간
    알고리즘이 사용하는 메모리의 용량을 말한다.

이 두 가지 기준은 서로 상충하는 경우가 많다.


***


# 알고리즘의 시간 복잡도 분석

두 알고리즘의 속도를 비교하는 가장 직관적 방법은 각각 구현한 뒤 같은 입력에 대해

수행 시간을 측정하는 것이다. 하지만 이 방법은 여러 환경적 요소(언어, 하드웨어,

운영체제, 컴파일러 등)에 따라 달라질 수 있기 때문에 기준이 되기에는 부적합하다.

따라서 알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정하고, 수행 횟수는

입력에 크기에 대한 함수로 표현한다.


### 다항 시간 알고리즘

변수 N과 N제곱, 그 외 N의 거듭제곱들의 선형 결한으로 이루어진 식들을 다항식이라

부른다. 다항 시간 속 알고리즘 간에는 큰 시간 차이가 날 수 있다.

- 선형 시간 알고리즘(Linear time)

    알고리즘의 수행 시간이 N에 정비례하여 그래프를 그려보면 정확히 직전이 되는

    경우 선형 시간 알고리즘이라 한다.

- 선형 이하 시간 알고리즘(Sublinear time) 

    이진 탐색(Binary search) 알고리즘은 lgN으로 표현되며 입력의 크기가

    커지는 것보다 수행 시간이 느리게 증가하는 이러한 알고리즘들을 
    
    선형 이하 시간 알고리즘이라고 한다.


### 지수 시간 알고리즘

N이 하나 증가할 때마다 걸리는 시간이 배로 증가하는 알고리즘들을 

지수 시간(Exponential time)에 동작한다고 말한다.

입력으로 주어지는 숫자의 개수가 아니라 크기에 따라 수행 시간이 달라지는

알고리즘들 또한 지수 수행 시간을 가질 수 있는데, 숫자가 특정 범위 안에

있다고 가정할 수 없는 경우, 숫자를 저장하는 데 쓰이는 비트의 수가 하나

늘어날 때마다 표현할 수 있는 수의 범위와 알고리즘의 최대 수행 시간이

두 배로 증가한다. 이렇게 입력의 크기를 입력이 차지하는 비트 수로 정의하면

입력의 크기에 대해 지수 시간이 걸린다고 할 수 있는 것이다.


## 시간 복잡도(Time complexity)

시간 복잡도란 가장 널리 사용되는 알고리즘의 수행 시간 기준으로, 알고리즘이

실행되는 동안 수행하는 기본적 연산의 수를 입력의 크기에 대한 함수로 표현한 것이다.

가장 깊이 중첩된 반복문 내부의 기본 연산들이 시간 복잡도의 대략적 기준이 된다.

시간 복잡도가 높다는 말은 입력의 크기 증가에 따라 수행 시간이 더 빠르게 증가한다는

말이다. 


- 입력의 종류에 따른 수행 시간의 변화

    입력의 크기 뿐 아니라, 어떤 형태인지에 따라서도 수행 시간이 달라진다. 배열에서

    주어진 숫자를 찾는 함수의 경우, 수행 시간은 찾는 원소의 위치에 따라 달라진다.

    따라서 수행 시간을 다음 기준에 따라 계산한다.

    - 최선의 수행 시간

    - 최악의 수행 시간

    - 평균적으로 기대되는 수행 시간


### 점근적 시간 표기: 𝑶 표기


시간 복잡도는 고려하기 힘든 문제가 있으므로, 반복문의 반복 수만 고려하게 된다.

그리고 이를 더욱 간단하게 표현한 대문자 𝑶 표기법을 사용해 수행 시간을 표기하는데,

𝑶 표기법에 따르면 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버리게 된다.

> Ex) ⨍(𝑵) = 3𝑵²- ㏒𝑵 + 16𝑵의 경우 𝑶(𝑵²)이 된다.

알고리즘의 입력의 크기가 두개 이상의 변수로 표현될 때도 마찬가지로 그중 가장

빨리 증가하는 항들만을 떼 놓고 나머지를 버린다.

> Ex) ⨍(𝑵) = 1/64𝑵²𝑴+ 64𝑵𝑴의 경우 𝑶(𝑵²)이 된다.

이 표기법은 수행 시간의 상한을 나타내지만, 최악의 수행 시간과는 관련이 없다.

예컨데, 퀵 정렬의 경우 최고차항이 𝑵²이고 최악의 시간 복잡도는 𝑶(𝑵²)이다.

하지만 평균 수행 시간의 최고차항은 𝑵lg𝑵이고, 최악의 시간 복잡도는 𝑶(𝑵lg𝑵)이 된다.


## 수행 시간 어림짐작하기

예측한 수행 횟수가 기준의 10분의 1 이하이거나 기준의 10배를 넘는 경우에만 이 법칙을 적용한다.

반복문 수행 횟수에 대해, 1초당 반복문 수행 횟수가 1억(10⁸)을 넘어가면 시간 제한을 초과할 가능성이 있다.

- 시간 복잡도가 실제 수행 속도를 반영 못하는 경우

- 반복문 내부가 복잡한 경우

- 메모리 사용 패턴이 복잡한 경우

- 언어와 컴파일러 차이

- 구형 컴퓨터의 경우

이 5가지 경우, 수행 시간을 짐작하는 것에 영향을 끼칠 수 있다.


## 계산 복잡도 클래스: P, NP, NP-완비

계산 복잡도 이론은 문제의 특성을 공부하는 학문이다. 문제의 쉽고 어려움을 구분하는 기준으로

난이도가 아닌, 수행 시간의 빠르기를 이용한다.

- P 문제

    문제를 해결하는 다항 시간 알고리즘이 존재하는 문제이다.
    
- NP 문제

    답이 주어졌을 때 이것이 정답인지 다항 시간 내에 확인할 수 있는 문제이며, 모든

    P 문제들을 포함한다.

- NP-난해 문제

    모든 NP 문제 이상으로 어려우며, 다항 시간 알고리즘이 아직 발견되지 않은 문제이다.

- NP-완비 문제

    NP-난해 문제이면서 NP인 문제들을 뜻한다.

