---
layout: post
title: 
subtitle: Flutter 앱 테스팅
tags:
- flutter
header-style: text
---

## 계기

플러터를 사용하여 정신없이 기능을 개발하는 도중에도 계속 생각나는 것이 있었다. 내가 짠 코드들을 다른 사람이
유지보수하기가 용이할까? Scalable한 어플리케이션은 새로운 요구 기능과 유저 유입에 대해 잘 대응하기 위해서
테스트와 디버깅이 용이해야한다. 첫 회사에서 10년 이상 된 레거시 프로젝트를 유지보수하며 그게 무엇을 의미하는지
어느 정도는 이해했다. 따라서 앞으로의 개발을 위해 플러터 테스팅에 대해 정리를 해놓고 싶었다.

참고
- [flutter test doc](https://flutter.dev/docs/testing)
- [dart test package doc](https://pub.dev/packages/test)
- [flutter test api](https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html)
- [the boring flutter dev show](https://www.youtube.com/watch?v=bj-oMYyLZEY)

## 테스트 환경

```dart
counter_app/
  lib/
    counter.dart
  test/
    counter_test.dart
```
test 폴더는 앱의 루트에 위치해야하고, 파일 이름은 _test로 끝나야 test runner가 실행할 수 있다.

```yaml
dev_dependencies:
  flutter_test:
    sdk: flutter
```

`flutter_test`는 `test` 패키지를 기반으로 만들어졌기 때문에, dev_dependencies에 `flutter_test`가 있으면 된다.

## 테스트의 종류 및 비교

|      | [<b>Unit</b>](#unit-test)| [<b>Widget</b>](#widget-test)  | [<b>Integration</b>](#integration-test) |
| <b>Confidence</b>        | Low | Higher | Highest |
| <b>Maintenance cost</b>  | Low | Higher | Highest |
| <b>Dependencies</b>      | Few | More   | Most |
| <b>Execution speed</b>   | Quick | Quick | Slow |

### Unit Test

Unit(하나의 기능, 메서드, 클래스)을 테스트한다. Unit Test의 목적은 다양한 상태속에서 로직 유닛이 정상적으로 작동하는 것을 확인하는 것이다.
보통 Unit Test는 테스트 과정에서 디스크를 읽거나 쓰지 않고 화면에 출력하지 않으며 유저 동작을 입력받지 않는다.

외부 resource의 상태에 관련없이 테스트가 가능해야하고 이를 위해 외부 dependency들은 [mocked out](https://flutter.dev/docs/cookbook/testing/unit/mocking)된다. 
Unit test를 위해선 [test](https://pub.dev/packages/test) 패키지를 import해야한다.

#### test, expect

```dart
import 'package:test/test.dart';
import 'package:counter_app/counter.dart';

void main() {
  test('Counter value should be incremented', () {
    final counter = Counter();
    counter.increment();
    expect(counter.value, 1);
  });
}
```

테스트는 `top-level test function`, test의 결과물을 검증하는 `top-level expect function`으로 이루어져있고,
두 가지 모두 test package에서 제공한다. 이 때, `only expect per test`를 신경써서 작성해야 하는데,
하나의 테스트에 많은 expect가 사용될 경우, 테스트 fail 로그에서 정확히 뭐가 잘못되었는지 알기 힘들기 때문이다.

#### Matcher

```dart
import 'package:test/test.dart';

void main() {
  test('.split() splits the string on the delimiter', () {
    expect('foo,bar,baz', allOf([
      contains('foo'),
      isNot(startsWith('bar')),
      endsWith('baz')
    ]));
  });
  test('.parse() fails on invalid input', () {
    expect(() => int.parse('X'), throwsFormatException);
  });
}
```

[Matcher]() 패키지에서 제공되는 상수, 함수들로 `expect`에서 더 복잡한 검증을 수행할 수 있다.
또한 `throwsA()` 함수나 `throwsException` 같은 Matcher 상수를 이용해 exception을 테스트할 수도 있다.


#### group

```dart
import 'package:test/test.dart';
import 'package:counter_app/counter.dart';

void main() {
  group('Counter', () {
    test('value should start at 0', () {
      expect(Counter().value, 0);
    });
    test('value should be incremented', () {
      final counter = Counter();
      counter.increment();
      expect(counter.value, 1);
    });
    test('value should be decremented', () {
      final counter = Counter();
      counter.decrement();
      expect(counter.value, -1);
    });
  });
}
```

만약 서로 연관된 테스트를 해야할 경우, test package에서 제공하는 group function을 사용한다. 이렇게 할 경우
실행 시 각 test의 description 앞에 해당 group의 description이 붙게된다.

#### setUp, tearDown

```dart
import 'package:test/test.dart';

void main() {
  HttpServer server;
  Uri url;
  setUp(() async {
    server = await HttpServer.bind('localhost', 0);
    url = Uri.parse('http://${server.address.host}:${server.port}');
  });
  tearDown(() async {
    await server.close(force: true);
    server = null;
    url = null;
  });
}
```
setUp과 tearDown function을 이용해서 테스트 사이에 코드를 공유할 수 있다. setUp 콜백은 group이나 test suite의 모든 테스트
전에 실행되고, tearDown은 모든 테스트 이후에 실행된다. tearDown은 테스트가 실패하더라도 실행된다.


### Widget Test

하나의 Widget에 대해 테스트한다.(다른 UI 프레임워크에서는 Component Test) 위젯 테스트의 목적은 위젯의
UI와 인터렉션이 기대한 대로 이루어지는지 검증하는 것이다. 위젯 테스트에서는 여러 개의 클래스를 다루며
적절한 위젯 lifecycle을 제공하는 테스트 환경을 필요로 한다.

위젯 테스트에서는 유저 행동과 이벤트 수신 및 응답, 레이아웃 수행, child 위젯 인스턴스화가 가능해야한다. 따라서 유닛 테스트보다
더욱 포괄적이지만, 실제 UI 시스템보다 간단한 테스트 환경을 적용할 수 있다는 점에서는 유닛 테스트와 같다.
위젯 테스팅을 위해서는 flutter에 관한 추가적인 유틸리티를 제공하는 [flutter_test](https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html) 패키지를 import해야한다. 

#### testWidgets

```dart
void main() {
  testWidgets('MyWidget has a title and message', (WidgetTester tester) async {
    // Test code goes here.
  });
}
```
`testWidgets`는 위젯 테스팅에서 일반 `test` 함수 대신 사용된다. 
이 함수는 각 테스트 케이스마다 새로운 `WidgetTester`를 만들고 이를 이용해 테스트를 수행한다. 

#### WidgetTester

```dart
void main() {
  testWidgets('MyWidget has a title and message', (WidgetTester tester) async {
    await tester.pumpWidget(MyWidget(title: 'T', message: 'M'));
  });
}
```

위젯테스터를 이용하여 테스트 환경 속에서 위젯을 build, interact 할 수 있다. 
호출된 pumpWidget은 건네받은 위젯을 build, render한다.
여기서 주의할 점이 있는데, 테스트 환경에서는 `StatefulWidget`이나 `animation`을 사용할 때 
`setState`가 자동으로 위젯을 rebuild 하지 않는다는 것이다. 
이 때는 아래 방법 중 하나를 택해서 구현한다.

`tester.pump(Duration duration)` 함수는 프레임을 예약하고 위젯 rebuild를 트리거한다. 만약 Duration을 전달받으면
해당 Duration을 적용하고 스케줄링한다.

`tester.pumpAndSettle()` 함수는 더 이상 예약된 프레임이 없을 때까지 지정된 Duration으로 pump()를 반복적으로 호출한다.
예약된 프레임이 없을 때에도 pump가 최소 한번은 호출되고, 기본적으로 모든 애니메이션이 끝날 때까지 기다린다. 
이 함수는 빌드 라이프사이클에 대한 세밀한 제어를 제공한다.

> 만약 애니메이션을 시작해야한다면, Duration 설정 없이 pump를 한번은 호출하여 ticker을 실행해야한다.

#### Finder

```dart
void main() {
  testWidgets('MyWidget has a title and message', (WidgetTester tester) async {
    await tester.pumpWidget(MyWidget(title: 'T', message: 'M'));
    final titleFinder = find.text('T');
    final messageFinder = find.text('M');
  });
}
```
Finder 클래스는 테스트 환경 속에서 위젯 트리를 훑으며 위젯을 찾음으로써 위젯들이 맞게 출력되는지 검증할 수 있다. 
이를 위해 `flutter_test` 패키지의 find constant를 이용한다. 이 상수는 `CommonFinders`를 제공하고,
이 클래스의 다양한 [함수들](https://api.flutter.dev/flutter/flutter_test/CommonFinders-class.html)을 
이용하여 위젯을 찾을 수 있다.

#### Matcher

```dart
void main() {
  testWidgets('MyWidget has a title and message', (WidgetTester tester) async {
    await tester.pumpWidget(MyWidget(title: 'T', message: 'M'));
    final titleFinder = find.text('T');
    final messageFinder = find.text('M');
    expect(titleFinder, findsOneWidget);
    expect(messageFinder, findsOneWidget);
  });
}
```

flutter_test는 `Matcher` 상수들을 통해 기존의 [Dart Matcher](https://pub.dev/documentation/matcher/latest/matcher/matcher-library.html)에서 제공하는 것 외에 위젯 테스팅을 위한 추가적인 `Matcher`를 제공한다. 
`Matcher`는 `expect` 함수에 주어져 `Finder`의 값이 기대값과 일치하는지 검증하는 일을 한다. 
아래는 위젯 테스팅에 주로 쓰이는 `Matcher`를 제공하는 상수, 함수들이다.

- findsNothing
- findsOneWidget
- findsWidgets
- findsNWidgets(n)
- matchesGoldenFile(key)

> matchesGoldenFile(key) 함수는 위젯의 렌더링이 비트맵 이미지와 맞는지 검증하는 `golden file` 테스팅에 사용된다.

#### Tap, drag, and enter text

```dart
void main() {

  testWidgets('Add and remove a todo', (WidgetTester tester) async {
    // 리스트 위젯 build
    await tester.pumpWidget(TodoList());
    // 텍스트 입력
    await tester.enterText(find.byType(TextField), 'hi');
    // 텍스트를 리스트에 추가
    await tester.tap(find.byType(FloatingActionButton));
    // 위젯 rebuild
    await tester.pump();
    // 텍스트 위젯 검증
    expect(find.text('hi'), findsOneWidget);
    // 드래그로 위젯 remove
    await tester.drag(find.byType(Dismissible), Offset(500.0, 0.0));
    // dismiss animation이 끝날 때까지 rebuild한다.
    await tester.pumpAndSettle();
    // 텍스트 위젯 검증
    expect(find.text('hi'), findsNothing);

  });
}
```

위젯들은 출력 뿐 아니라 유저 인터렉션에 반응해야한다. 이를테면 탭이 가능한 버튼, 텍스트 입력이 가능한 텍스트 폼 등이 있다.
이것들을 테스트하기 위해서는 `WidgetTester` 라이브러리를 이용해 테스트 환경에서 시뮬레이션해야한다.
아까 말했다시피 테스트 환경에서는 위젯이 자동으로 rebuild되지 않으므로, `pump()`나 `pumpAndsettle()` 함수를 같이 사용해야한다.
아래는 `WidgetTester`가 제공하는 함수들이다. 

- enterText()
- tap()
- drag()


### Integration Test
앱의 큰 부분 혹은 앱 전체를 테스트한다.


### Bloc Test

## 다음

이후 포스트에서는 `mockito`를 사용한 목업과 `golden file testing`에 대해서 다루어보려고 한다.