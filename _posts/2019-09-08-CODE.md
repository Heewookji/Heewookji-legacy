---
layout: single
title: CODE - Charles Petzold
tags: [DevelopmentDiary]
toc: true
toc_sticky: true
---

# 찰스 펫졸드의 CODE를 읽고 나서

***

### 계기

2018년 2월, 졸업을 앞둔 평범한 미대생이었던 나는 졸업전시를 준비했어야 했으므로 

당시 이수하고 있던 복수전공 공업디자인의 캡스톤 수업인 UX/UI와 인터렉션 디자인 수업을 수강하게 되었다.

수업을 진행하면서 서비스 기획 단계에서의 리서치와 아이디어 도출, 서비스 프로토타입 제작까지

일련의 과정을 거쳤는데, 나와 나의 팀원이 선정한 주제는 '천식 환자를 위한 IOT 흡입기'였다. 

리서치부터 기획까지 꽤 순조롭게 진행하고 있었지만 학과 특성상 중요시되는 최종 프로토타입을 만드는 것이

문제가 됐었고, 외주를 맡겨 완성하거나 직접 만드는 두 가지 방법 중 고민했다.

돈 없고 가난한 학생은 모든 것을 직접 만드는 방법을 택했고, IOT 제품의 프로토타입을 만드는 것에 쓰이던

아두이노를 사용하기로 했다. 아두이노를 사용하는 일에는 빵판과 기판들을 태워먹지 않을 전자회로 개념 외에도

몇 가지 부류의 기초 지식이 필요했는데, 그 중 하드웨어에게 명령을 내리는 것은 내게 친숙하지 못한 것이었다.

하지만 어쨋든 해야할 일이었고, 아두이노 통합 개발환경(IDE) 속에서 CODE를 처음으로 보았다.



겁냈던만큼 어렵지 않다고 느끼게 된 것은, 여러 블로그를 돌아다니며 아두이노의 기본적 기능들을 

파악했다고 생각했을 때였다. 애초에 아두이노는 나와 같이 코드에 무지하지만 여러 프로토타입들을 만들어보고

싶은 사람들을 위한 것이기에 구현하고 싶은 기능에 대한 튜토리얼은 인터넷을 뒤지면 쉽게 찾을 수 있었고,

내가 해야할 일은 그저 주석에 달린 설명문들과 주변 코드의 문맥을 통해 한 뭉큼의 코드 덩이가

어떤 기능을 담당하는지 눈치채고 응용하는 것 뿐이었다. 11월에 이르러 졸업 전시에 필요한 프로토타이핑을

무사히 완성한 뒤, 코딩에 재미를 붙인 나는 서비스의 기획과 디자인 뿐 아니라 구현에도 깊은 관심을

가지게 되었다. 실제 기획한 서비스를 상용화 해보고 싶었고, 그러기 위해 디자이너면서 

기술자가 되고 싶었다. 졸업까지 들어야하는 학과 수업이 없었고, 국비지원수업 중 웹 개발 수업이 있다는 것을

알게 되어 12월 28일부터 국비지원 웹개발 수업에 들어가기로 결정했다.



CODE는, 12월 28일까지 약 한달 동안 비전공자인 내가 컴퓨터 공학에 관한 기반 지식을 쌓게 해줄 책이었다.

개발을 배워보기로 마음먹고, 개발자들의 필독서 중에서 교양서에 가까운(진입장벽이 비교적 낮다고 여겨지는)

책을 찾았는데 그게 바로 이 CODE라는 책이었다. 물론, 초반부에서는 즐겁게 읽으며 교양서의 정취를 느끼다가

중후반으로 들어가며 즐거움과 고통, 어느 정도의 자괴감까지 복합적인 감정을 느낄 수 있었다. 

본래 한 달동안 읽고자 했지만, 한 페이지를 이해하기 위해 꽤 긴 시간동안 끙끙 앓는 일도 빈번해

결국 국비 교육을 받는 동안 자바 개념서와 동시에 틈틈히 읽어야했다. 그래도 뿌듯한 점은, 개념을 이해하기 위해

종이에 그림과 프로세스들을 그리고 머리를 감싸쥐며 고민하면서도 다음 쪽을 읽을 수 있을만큼

이해를 하기 전엔 넘어가지 않았으며 마지막 쪽을 읽을 때까지 타협하지 않았다는 점이다. 

다만 읽을 당시 이해한 수준이 얕을 것이라고 생각하기 때문에 이후 다시 읽을 생각을 하고 있다.

***

### 내용

이 책의 주요한 특징이며 가장 인상깊었던 점은 컴퓨터가 만들어지기까지의 과정을 순차적이며 풍부한 예시와

친절하고 세세한 설명, 그림을 통해 따라간다는 점이다.

처음 시작은 밤중에 건너편에 사는 친구와 소통하기 위한 손전등 부호부터이다. 좀 더 편리한 모스 부호와 점자,

이진 부호를 따라 올라가고 이진 부호와 전기 회로와의 유사점(전류의 흐름과 흐르지 않음)을 이용해

회로를 통해 부호를 전달한다. 긴 거리를 위해 전신과 릴레이를 만드는 법에 대해 설명하고, 이진수 체계와

부울 대수(Boolean algebra)를 이용해 논리 회로를 만든다. 이후 릴레이를 여러 개 연결해 논리 게이트

AND, OR, NOR, NAND를 만들어보고, 논리 게이트들을 이용해 덧셈, 뺄셈이 가능한 가산기를 만든다.

게이트의 출력이 다른 게이트의 입력으로 들어가는 피드백(feedback)을 이용해 플립플롭(flip-flop) 회로를

만들어 값 보존 신호 이후 입력에 상관없이 값을 보존해 정보를 저장하고, 이 래치를 가산기에 적용해

8-bit 래치에 저장된 데이터를 바로 바로 계산한다. 또, 클럭값이 1일 경우에 값을 바꾸는 레벨 트리거 방식의

플립플롭과 달리 클럭값이 천이(0에서 1로 변하는)될 때에만 값이 변하는 엣지 트리거 플립플롭을 

오실레이터(clock)와 연결해 2진수를 셀 수 있는 계수기(Counter)를 만든다.

다음으로는 8개의 1비트 래치를 연결해 8X1 RAM(Random Access Memory)을 만든다. 

1:8 DEMUX를 통해 1비트 입력은 8곳의 출력 중 선택된 곳에 배분되고, 출력과 연결된 1비트 래치에 저장된다. 

래치에 저장된 데이터는 8:1 MUX를 통해 8곳의 입력(래치)중에서 1비트 출력을 보내준다. 

이렇게 만들어진 8X1 메모리 2개에 같은 주소를 줌으로써 8X2 메모리를 만들거나, 2:1 선택기(2:1 MUX)와

1:2 디코더(1:2 DEMUX)를 통해 묶고 16X1 메모리를 만들 수 있다. 그리고 최종적으로는 더 많은 메모리들을

묶고 합쳐 64KB(64kX8)의 메모리를 사용하게 된다.

이 메모리는 누산기(Accumulator)와 계수기(Counter)에 연결되고, 램에 미리 적어놓은 8비트의 데이터들은

계수기에 의해 연결된 주소가 자동 증가하면서 누산기에 의해 더해진다. 순차적이며 자동적인 이 계산기가 중간에

저장(Store), 로드(Load), 더하기(Add), 정지(Halt)와 같은 기본적 기능을 할 수 있도록 똑같은 크기의

메모리를 하나 더 준비하는데 이것이 명령어 메모리가 된다. 기존 데이터 메모리와 공유하는 주소에서

명령어 메모리에는 각각의 명령어 동작코드(Opcode)에 해당하는 값이 들어가 있고, 이 값에 따라

명령어 메모리에 연결된 하드웨어(논리 게이트 조합)들이 선택기나 클럭, 지우기에 대한 제어 신호를 보내게 된다.

그 다음에는 메모리의 뒤에서도 앞의 데이터에 접근하여 저장하거나 로드할 수 있도록 명령어를 

1바이트가 아닌 3바이트(명령어 1바이트 + 주소 2바이트)로 만드는데, 메모리에서 명령어를 가지고 오는 과정인

명령어 패치(Instruction Fetch)를 위해 클럭 신호가 3번 뛰면서(1번에 1개의 명령어를 가져오기에) 

3개의 래치 각각에 명령어, 주소1, 주소2를 저장하고, 복잡한 제어 신호를 가지게 된다. 

이제 2개의 메모리는 합쳐져 한 개의 메모리 안에 명령어와 데이터를 저장하게 되고, 데이터를 명령어로

인식하지 않으면서 프로그램이 끝까지 정상적으로 실행될 수 있도록 계수기에 회로를 추가하여 분기(Jump)

명령어를 구현한다. 그 뒤에 더하기 명령을 여러 번 반복해야 하는 곱하기 명령을 위해, 제로 플래그를 이용해

피승수가 0이 될 때까지 반복하는 조건 분기 명령(계산기와 컴퓨터를 구분하는 가장 중요한 요소는 조건에 따른

제어가 가능한 루프 기능이다.)을 만들어 비로소 컴퓨터라고 할 수 있는 것을 만들어낸다. 컴퓨터는 프로세서,

메모리, 입/출력 장치로 구성되어 있는데 우리가 만든 프로세서(혹은 CPU - Central Processing Unit)는
 
8비트 프로세서로서 내부에 덧셈기라는 수치 연산 및 논리 연산 유닛(ALU - Arithmetic Logic Unit)을

가진다. 이러한 하드웨어와 별개로 소프트웨어는 메모리에 입력된 명령어들과 데이터들을 뜻하며 프로세서의 

명령어 동작코드는 머신 코드 혹은 기계어라 부른다. 기계어를 축약어인 니모닉(Mnemonics)과 메모리 주소인 

레이블로 표현하는 컴퓨터 언어는 어셈블리어이며, 구동을 위해 어셈블리어를 어셈블(기계어로 변환) 하게 된다. 





이후에는 연산과 계산 장치에 대한 역사를 살펴 보는데, 주판부터 시작해서 거대한 기계식 덧셈기인 찰스 배비지의 

차분기관(Difference Engine)이 있고, 현대 컴퓨터에 가까우며 카드로 프로그래밍을 할 수 있는

해석기관(Analytical Engine)이 있다. 

릴레이 기반의 컴퓨터(전기기계식 컴퓨터)는 수명이 짧고 오동작하는 경우가 있었고, 그 이후에 사용된 진공관 기반

컴퓨터(전자 컴퓨터)은 비싸고 전력 소모가 심하며, 열이 많이 발생해 언젠가 타버리는 단점을 가지고 있었다.

명령어와 데이터가 같은 메모리에 존재하며, 프로그램 카운터에서 주소를 지정하고 조건 분기를 허용해야 한다는

저장된 프로그램(Stored-Program) 개념의 컴퓨터 설계는 폰 노이만 아키텍쳐로 불리게 된다.

기업과 정부에 의한 컴퓨터 역사와 별개로, 가정용 컴퓨터의 역사는 진공관을 대신할 증폭기인 트랜지스터가

발명되며 발전해나간다. 트랜지스터들을 미리 연결하여 구성해놓은 집적회로(Integrated Circuit, IC)가

발전되면서, 하나의 칩 안에 집적될 수 있는 트랜지스터 수는 무어의 법칙에 따라 2배씩 늘어나게 된다.

이후 단 하나의 칩안에 프로세서(CPU)를 구현한 마이크로프로세서 컴퓨터(단일 칩 컴퓨터)가 인텔에 의해 

개발되었는데, 이 4004 프로세서는 4비트 프로세서로 데이터 패스가 4비트이고, 오실레이터로부터 받을 수 있는

최대 클럭속도가 108KHZ이며, 메모리의 크기는 640바이트였다. 

이 3가지의 속성은 컴퓨터의 속도에 대해 알려주는 지침이 된다.




이후에는 책에서 만든 프로세서가 아닌, 시중에 판매되었던 두 가지 고전적인 마이크로프로세서의 동작을 설명한다.

첫 번째로 인텔의 8080 프로세서에 대해 알아보는데, 이 프로세서는 256개의 명령어와 계산을 빠르게 해주기 위한

누산기 외의 레지스터들 또한 가지고 있다.(일반적으로 메모리 접근 횟수와 프로그램 실행 속도는 반비례한다.)

8080프로세서는 메모리의 일부를 후입선출(Last In First Out - LIFO)형 메모리인 스택(Stack) 영역으로 

사용하는데, 이를 위해 스택 주소를 지정하는 특별한 16비트 레지스터를 가지고 이를 스택 포인터(Stack Pointer)

라고 부른다. 스택 포인터는 PUSH나 POP 명령어에 따라 주소값이 감소되거나 증가하거나 하며 해당 주소에 현재

레지스터 혹은 누산기의 값을 저장한다. 이 때 스택이 너무 커지면 스택 오버 플로(Stack Overflow)가 발생하고,

스택을 모두 소모하고도 그 다음에 접근하고자 하는 경우 스택 언더 플로(Stack Underflow)가 발생하게 된다.

Call과 Return 명령어의 경우, Call로 분기를 하면서 스택에 이전의 주소를 푸시해두고 Return으로 해당 주소를

팝하여 돌아가는 동작을 수행함으로써 서브루틴(Subroutine)을 구현할 수 있다.

마이크로프로세서는 일반적으로 메모리에 접근하는 것과 비슷하게 데이터를 적거나 읽음으로써 주변 장치에 접근할 수

있는데, 이를 Memory Mapped I/O 방식이라고 한다. 

그러나 메모리 접근 영역인 65,536번지(8080프로세서의 경우) 이외에 입/출력을 위한 추가적인 주소를 할당하는 

경우 이를 I/O mapped I/O 방식이라고 하며 이러한 주소들은 I/O 포트라고 부른다. 

주변장치는 마이크로프로세서에 인터럽트 신호를 보내고, 마이크로프로세서가 인터럽트를 받아들일 준비가 됐다고 

알릴 때, 해당하는 RST 명령어를 출력해 마이크로프로세서가 프로그램 카운터를 스택에 저장하고 인터럽트를 

처리하는 프로그램 영역(키보드로부터 한 바이트를 읽을 수 있는 등의 프로그램)으로 분기할 수 있도록 한다.

다음으로는 모토로라의 6800 프로세서를 살펴본다. 6800 프로세서는 동작코드와 니모닉은 완전히 다르지만, 결과적으로

8080 프로세서와 동일한 동작을 수행할 수 있다. 이 두 개의 프로세서는 서로 비호환성(Incompatibility)을 가지며,

이진 호환성(Binary Compathibility), 쉽게 말해 서로의 기계어를 구동시키는 것이 불가하다고 할 수 있다.

이 비호환성의 한 예로, 인텔은 하위 바이트가 먼저 오는 리틀 엔디안(Little-Endian)을 사용하지만 모토로라는 

상위 바이트가 먼저 오는 빅 엔디안(Big-Endian) 방식을 사용한다. 각 회사의 프로세서들은 하드웨어와 소프트웨어상에서

발전하며, 기존 명령어 셋을 지원하면서도 명령어 수를 늘려나간다. IBM, 모토로라, 애플 등 3사의 공동 개발로 

RISC(Reduced Instruction Set Computing - 동작코드의 형태, 수를 간략하게 만들면서 많은 레지스터를 가지고

메모리 접근을 최소화해 동작속도를 높이고자 한 컴퓨터 구조) 기반의 프로세서인 PowerPC 프로세서가 사용된다.



이후에 문자를 표현하기 위해 ASCII(American Standard Code for Information Interchange)라는 1바이트

미국 표준 부호를 설명하고, 아스키 부호의 여러 가지 확장 형식과 그에 따른 호환성 문제에 대해 알아본 뒤

이를 해결하기 위한 2바이트 문자체계인 유니코드를 배운다.(유니코드의 처음 128 문자는 ASCII 문자와 동일하다)

컴퓨터를 구성하는 집적 회로는 회로 기판에 부착되고, 이런 여러 회로 기판 간의 통신에는 버스(Bus)라는 것이 이용된다.


- 버스에 사용되는 3가지 신호

|            주소 신호             |           데이터 입/출력 신호              |    제어 신호        |
| :---------------------: | :----------------------: |:-----------------------:|
| RAM, 주변장치에 접근하기 위한 신호  | RAM, 주변장치에 데이터를 입/출력하는 신호 | 컴퓨터를 동작시킬 때 쓰이는 신호 |



이 뒤에는 버스에서 신호를 받는 여러 인터페이스들에 대해 설명한다. 메모리 보드가 어떻게 만들어지는지, 출력장치가 

어떻게 문자를 출력할 수 있는지, 키보드는 사용자가 입력한 값을 어떻게 전달하는지, 

장기보존장치(Long-Term Storage Device)가 어떻게 발전해왔는지에 대해서 충분히 설명한 뒤, 파일 저장에 대해

운영체제(Operating System)를 엮어 보여준다.

운영체제에서는 그동안 사용해온 0과 1뿐인 제어판을 버리고 인터럽트에 해당하는 주소에 키보드 처리 프로그램과 

명령어 처리기를 만든다(대화형-Interactive 컴퓨터의 시작). 이후 이 프로그램과 처리기로 만든 프로그램이

리셋과 함께 사라지지 않도록 읽기 전용 메모리(ROM)에 저장한 뒤, 이 ROM이 RAM보다 더 상위 번지에서 

먼저 시작되도록 하여 시스템이 재구동을 시작해도 ROM에 남아있는 프로그램이 구동을 할 수 있게된다. 명령어 처리기가 

ROM에 남아 있으므로, 이제는 RAM에서 디스크 드라이브로 데이터를 적고 다시 데이터를 RAM으로 읽어올 수 있게된다.

하지만 어디에 어떤 것이 저장되어 있는지 기억해야하고, 프로그램이 이전과 다른 주소로 로드된다면 정상적으로 

동작하지 않는 문제가 발생한다. 또한 큰 프로그램은 디스크의 섹터 크기보다 큰 경우 몇 개의 섹터에 걸쳐 저장되기에,

디스크에 저장된 것을 모두 파악하고 있어야한다는 점도 있다. 따라서 하나 혹은 다수의 섹터에 저장된 관련성 있는 

데이터들을 하나의 집합으로 만들어주는 파일 시스템(File Systme)의 필요성이 대두된다. 

운영체제는 디스크에 저장되어 있고, 구동되기 위해서는 메모리에 로드되어 있어야한다. 

이를 위해 ROM에는 부트스트랩 로더(Bootstrap Loader)라는 작은 프로그램이 들어있고, 이 프로그램이 디스켓의 

첫 섹터 내용만 읽어 이를 수행시킨 뒤 수행된 첫 섹터(부트스트랩)가 나머지 운영체제를 메모리로 로드하게 된다.

이를 부팅(Booting)이라 한다.




- 운영체제가 로드된 이후 메모리 배치 상태


|     시스템 파라미터     |  
| 임시 프로그램 영역(TPA)  | 
| 콘솔 명령어 처리기(CCP)  | 
| 기본 디스크 운영 체제(BDOS)| 
| 기초 입출력 시스템(BIOS) | 



운영체제 위에서 돌아가는 프로그램은 해당 하드웨어에 접근해 데이터를 읽고 쓸 수는 없다. 이러한 공통적이며 자잘한

작업들은 운영체제가 맡아 처리하고, 프로그래머는 운영체제가 제공하는 서브루틴을 이용함으로써 주변장치에 대한 깊은

이해 없이도 모든 하드웨어에 쉽게 접근할 수 있다. 이렇게 운영체제가 제공해주는 접근 방법을 응용프로그램 인터페이스

(Application Programming Interface -API)라고 한다.



운영체제 단원이 끝난 뒤, 이진수로 이루어진 데이터가 실수를 표현하는 방법 -고정 소수점과 부동 소수점-에 대해

설명한다. 부동 소수점이 필요한 이유와 부동 소수점에 대한 표준을 다룬 뒤, 부동 소수점을 지원하는 프로세서,

하드웨어의 역사에 대해 간략히 말해준다.

이 다음에는 저수준 언어와 고수준 언어에 대해 다룬다. 이제는 어셈블을 직접 손으로 하지않고, 운영체제에 포함된

어셈블러를 이용해 어셈블한다. 그럼에도 여전히 어셈블리어는 (프로세서 수준에서 대응되므로) 따분하고, 이식성이

없다는 단점이 있다. 따라서 프로세서 의존적 명령어 대신, 연산 기호와 같은 개념을 이용해 프로그래밍하는 방식이

필요해지고, 이러한 방식의 프로그래밍 언어를 고수준 프로그래밍 언어(High-Level Programming Language)라고

부른다. 어셈블리어는 하드웨어와 밀접한 관계를 가지므로 저수준 언어(Low-Level Language)라 불린다.

고수준 언어의 경우 쉽고 특정 프로세서에 의존성을 갖지 않지만, 프로세서 자체적 기능을 쓰지 못하거나 느린 실행속도 등

저수준에 비해 성능 부분에서 비효율적일 수 있다.

이후에는 고수준 언어의 역사와 동작하는 방식 및 문법에 대해 ALGOL이라는 프로그래밍 언어를 예를 들어 설명한다. 

언어의 구현에는 ALGOL같이 소스코드 파일을 읽어 실행 파일을 만드는 컴파일러, 소스코드 파일을 읽어서 수행 파일을

만들지 않고 바로 실행하는 인터프리터(Interpreter)가 있다. 이러한 ALGOL 형식의 언어들은 널리 사용되다가

객체지향 언어(Object-Oriented Languages)까지 이르게 된다.



마지막 장에서는, 점점 작고 빨라지는 컴퓨터가 남은 성능과 속도를 유용하게 활용하는 방법인 인터페이스의 향상이란 

주제로 끝마친다. 사람과 컴퓨터는 다른 부분이 많기에 상호작용이 필요했다. 초기의 컴퓨터는 데이터를 받아 한번에 

일괄적으로 처리했지만, 한 줄의 명령 뒤에 몇 줄의 응답이 오는 텔레타이프 방식부터 사람과의 상호작용이 시작됐다.

사용자와 컴퓨터 사이의 상호작용은 점점 빠른 반응 속도를 가지고, 문자 기반의 출력에서 그래픽 기반의 출력으로

넘어가게 된다. 초기엔 픽셀을 표현하기 위해 대용량 메모리를 요구하는 래스터(Raster) 표시 장치 대신 벡터(vector)

표시 장치들이 사용되었다. 이후 래스터 표시 장치가 충분히 저렴해지면서, 마우스를 이용해 화면에 있는 요소들과

상호작용하는 등 대화형 그래픽 컴퓨팅이 발전하게 된다. 입력을 받고 결과를 출력하는 텔레타이프 형식이 아닌, 정보를

표시하고 사용자의 입력을 직접 받는 소프트웨어들이 나타나고, 여러 프로그램은 윈도우(Window)에 들어가 한 화면에

동시에 출력할 수 있게 되었다. 이후 운영체제는 선, 사각형, 타원, 문자 등을 출력해주는 API 함수를 포함하는 완전한

그래픽 프로그래밍 시스템을 제공하고 이러한 운영체제를 위한 응용 프로그램들은 더 이상 어셈블리어로 작성되지 

않았다. 윈도우 응용 프로그램의 경우 C언어로 작성되었고, 이후 화면상의 객체들이 서로 연관된 방식처럼 프로그래밍하는 

객체 지향 프로그래밍(Object-Oriented Programming, OOP)이 나타난다. 객체지향 언어는 프로그래머가 

구조적으로 더 나은 해결 방법을 고려하도록 해줬고, API를 직접 호출하지 않고 관련 객체를 이용함으로써 

서로 다른 운영체제 위에서 동작이 가능하게 해줬다.

이후에는 데이터의 형식, 압축 알고리즘, 음성 인식, 컴퓨터간의 통신에 대해 설명한다. 통신의 경우, 초기엔 전화선으로

이루어졌으므로 비트와 소리간의 변환을 해주는 모뎀(MODEM; modulator/demodulator 변조기/복조기)을 이용하는

직렬 통신 인터페이스를 사용했다(프린터의 경우 8개의 전선을 통해 한 번에 8개의 비트를 전송하는 병렬 인터페이스).

사람들은 컴퓨터와 모뎀을 이용하여 다른 컴퓨터에 접속해 파일을 다운로드 받곤 했고, 이러한 개념은 대형 정보 서비스로

확장된다. 인터넷은 여러 데이터가 중앙에 집중되어 있지 않고, 통신을 위한 일련의 프로토콜(Protocol, 통신 규약)이

존재했다. 이 중 가장 중요한 것은 TCP/IP라는 통신 제어 프로토콜(Transmission Control Protocol, TCP)과

인터넷 프로토콜(Internet Protocol, IP)로 이루어진 프로토콜이었다. TCP/IP는 단순히 문자를 전송하지 않고,

큰 블록의 데이터를 작은 단위의 패킷으로 잘라 각각 전송하고 이후에 수신측에서 합치게 한다.

인터넷의 그래픽 부분에서는 HTTP(Hypertext Transfer Protocol, 하이퍼텍스트 전송 프로토콜)을 이용하는 월드

와이드 웹(World Wide Web)이 가장 유명하다. 웹 페이지에서 보여주는 내용은 텍스트 형식인 HTML(Hypertext 

Markup Language)로 정의된다. 여기서는 연관된 정보를 링크함으로써 쉽게 다른 웹 페이지를 띄울 수 있다.

HTML은 문서 형식에 대한 정보를 포함한 ASCII 텍스트 파일로써 RTF(Rich Text Format)과 유사한 부분이 있다.

대부분의 월드 와이드 웹 브라우저(Web Browser)는 HTML을 볼 수 있게 만들어주고, 이는 텍스트 파일 형식의 장점이다.

웹 브라우저는 HTML 파일을 읽어 텍스트와 그래픽을 적절히 위치시켜준다. 또한 특정 페이지를 보고 있는 동안, 특별한

형태의 프로그램이 클라이언트 상에서 구동될 수 있도록 자바스크립트 문장을 읽어 해석한다.



이제는 전기를 통해 데이터를 전송하는 방식에서 벗어나 빛을 이용해 데이터를 전송하는 기술이 발전하고 있고, 데이터의

전송은 초당 수십억 비트까지 늘어날 수 있다. 하지만 이 책의 마지막에서 말하듯이 광통신 또한 결국 친구와 손전등 

불빛을 깜빡이며 모스부호를 전달하는 과정을 아주 빠르게 한 것과 같다.






> 이 책을 완독하는 것과 마찬가지로, 읽은 내용을 다시 읽고 되짚어 가면서 독후감을 쓰는 일에 생각보다 많은 시간이 걸렸다.
> 처음 쓸 때에는 간략히 정리하고자 했지만, 막상 시작하니 간략히 하기가 쉽지 않았다. 결국 스스로 중요하게 생각했던
> 부분과, 생략이 필요한 부분으로 나누어 적었고, 지나서 보니 독후감이라기 보단 책 내용을 되짚기 위한 포스트가
> 된 것 같다. 책을 읽는데 익숙하지 않았던 용어들에 대해 알게 되었고, 관련 내용을 공부한 뒤에 다시 읽을 때는
> 더 깊은 시각을 가지고 읽게 되었으면 좋겠다.



